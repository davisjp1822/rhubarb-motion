/*
*	motion_control.c
*	rhubarb_motion
*
*	Created by John Davis on 2/20/17. Copyright 2017 3ML LLC
*
*/

#include <stdint.h>
#include <assert.h>
#include <time.h>
#include <math.h>
#include <inttypes.h>

#include "motion_control.h"
#include "globals.h"

/* STATE MACHINE SETUP - STEP 1
 * The next several blocks will setup the state machine.
 *
 * First, we define our states. The states are the actual functions that will be called by the control loop.
 * They take no arguments and return a return code based on whether they fail, pass, or repeat.
 *
 */

static uint64_t motor_pos = 0;
static uint64_t acc_stop_point = 0;
static uint64_t dec_start_point = 0;
static int8_t should_pulse = FALSE;
static struct timespec main_timer;
static struct *move_params this_move;

/*
 * The state functions defined below define the actual actions in the state (move logic, etc).
 * The do NOT define transition logic - they just return values as defined by state_ret_codes.
 *
 * The transition logic is defined by lookup_transitions.
 */

static int state_start(void);
static int state_accel(void);
static int state_run(void);
static int state_decel(void);
static int state_estop(void);
static int state_exit_success(void);
static int state_exit_fail(void);

static enum state_codes lookup_transitions(enum state_codes cs, enum state_ret_codes rc);

/* STATE MACHINE SETUP - STEP 2
 * Next, we setup a function pointer and some variables. 
 * A quick note on function pointers. They are like placholders for actual functions. They define what the function looks like, not what the actual function is.
 * This will make more sense in the command loop in execute_move(). Instead of having a giant if/then/else or switch statement, function pointers allow
 * for a very simple state machine loop as the function pointer can be swapped to represent the different state_* functions
 */

/* Here we define an array of function pointers, along with an enum which gives a name to each index of the array.
 * The defintion arguments NEED to match the names of the state functions declared above
 */
int (*state[])(void) = {state_start, state_accel, state_run, state_decel, state_estop, state_exit_success, state_exit_fail};

/* this enum allows us to refer to the array members above by name, rather than index. For example, state_start == 0, etc
 * These values HAVE to be in sync with the array of function pointers above
 */
enum state_codes = {state_start, state_accel, state_run, state_decel, state_estop, state_exit_success, state_exit_fail};

/* set another enum to give us more legible state return codes */
enum state_ret_codes = {done, fail, repeat, estop};

/* STATE MACHINE SETUP - STEP 3
 * This table is very important. This is where all of the possible state transitions are mapped. The template is the "transition" struct -
 * which defines a src state (could be current state), the return code from that state, and then the next state based on the return code
 * 
 * Transitions from the exit and estop states don't need to be defined, because we, well, end.
 *
 * The transition map comes from your state diagram. In the case of this program, the diagram (plotted in GNU Dia), may be found in this Github repository.
 */

static struct transition
{
	enum state_codes src_state;
	enum ret_codes ret_code;
	enum state_codes dst_state;
}

static struct transition state_transitions[] =
{
	{state_start, done, state_accel},
	{state_start, fail, state_exit_fail},
	{state_start, repeat, state_exit},
	{state_start, estop, state_estop},

	{state_accel, done, state_run},
	{state_accel, fail, state_exit_fail},
	{state_accel, repeat, state_accel},
	{state_accel, estop, state_estop},

	{state_run, done, state_decel},
	{state_run, fail, state_exit_fail},
	{state_run, repeat, state_run},
	{state_run, estop, state_estop},

	{state_decel, done, state_exit_success},
	{state_decel, fail, state_exit_fail},
	{state_decel, repeat, state_decel},
	{state_decel, estop, state_estop}

}

int execute_move(struct *move_params mp)
{
	/*
	 * when first entering the move, set current state to state_start and init all variables
	 *
	 * current_state = the state the machine is currently in
	 * rc = return code variables
	 * m_state = function pointer that can be assigned to any of the state_* functions
	 *
	 */
	
	this_move = mp;
	enum state_codes current_state = state_start;
	enum state_ret_codes rc;
	int (*m_state)(void);

	/* this is the main control loop for the state machine 
	 *	
	 *	Thanks to using function pointers, the state machine is quite straightforward. 
	 *	Essentially, m_state is set to point to the current state's state_* function.
	 *	Then, the return code generated by the execution of the appropriate state function is stored in rc.
	 *	Based on the code stored in rc (done, fail, estop, etc), move forward, or don't if it is an exit state or estop state
	 *
	 *	All the while, the called functions (state_start, state_accel, state_decel) are setting the pulse interval,
	 *	which is being executed here.
	 */
	for(;;)
	{
		m_state = state[current_state];
		rc = m_state();
		
		/* setup some conditionals. if in an exit state or estop state, break the loop and exit.
		 * otherwise, call the lookup function to find the next state
		 */
		if(current_state == state_exit_success)
		{
			break;
		}

		if(current_state == state_exit_fail)
		{
			/* the calling function should print an error message */
			return EXIT_FAILURE;
		}

		if(current_state == state_estop)
		{
			/* the calling function should print an error message */
			return EXIT_FAILURE;
		}

		/* if we made it past the conditionals, call the state transition lookup and proceed! */
		current_state = lookup_transitions(current_state, rc);
	}

	/* get here only if we break the for loop due to getting to state_exit_success */
	return EXIT_SUCCESS;
}

static enum state_codes lookup_transitions(enum state_codes cs, enum state_ret_codes rc)
{
	/*
	 * loop through the array state_transitions and find our current state, cs, and the return code.
	 * fetch the next value in the sub array and return the next state code
	 */

	enum state_codes ret_state;
	int8_t i = 0;
	int8_t found = 0;

	for(i=0; i < (sizeof(state_transitions) / sizeof(state_transitions[0])); i++)
	{
		struct *transition t = &state_transitions[i];
		
		if(t->src_state == cs && t->ret_code == rc)
		{
			ret_state = t->dst_state;
			found = 1;
		}
	}

	/* assert that we found a valid state. if not, something is very wrong and we should abort */
	assert(found == 1);
	
	/* also throw in a debug message about a state change */
	if(VERBOSE == TRUE)
	{
		if(ret_state != cs)
		{
			char state_name[100];

			switch(ret_state)
			{
				case state_start:
					state_name = "start";
					break;

				case state_accel:
					state_name = "accel";
					break;

				case state_run:
					state_name = "run";
					break;

				case state_decel:
					state_name = "decel";
					break;

				case state_estop:
					state_name = "e-stop";
					break;

				case state_exit_success:
					state_name = "exit with success";
					break;

				case state_exit_fail:
					state_name = "exit with fail";
					break;
				
				default:
					break;
			}

			fprintf(stderr, "\nTransitioning to state: %s\n", state_name);
		}
	}

	return ret_state;
}

static int state_start(void)
{
	/* default state is success - unless one of our conditionals fails... */
	enum state_ret_codes rc = done;
	
	/*
	 * the starting logic is simple. init the following variables
	 * motor_pos - tracks motor position in steps (always starts at 0)
	 * main_timer - the main timer that controls the output pulsing
	 * should_pulse = TRUE or FALSE - should the output be pulsing?
	 */

	motor_pos = 0;
	should_pulse = TRUE;
	
	/* if we can't init the clock, bail from the program as something is REALLY not right */
	if(clock_gettime(CLOCK_MONOTONIC, &t) < 0)
	{
		perror("!!! ERROR:");
		rc = fail;
	}

	/* MOTION CALCULATIONS
	 * Currently, the math here will generate a trapezoidal move profile.
	 * If you wanted to create a different motion profile - sinusoidal for instance - you would have to tweak the math.
	 * What is being calculated here is the accel stop point and the decel start point. In theory, these wouldn't change for a sin move.
	 * Most of the change would be done in the acc and dec profiles ... I think.
	 *
	 * Anyway, deriving the distance required for acceleration is easy:
	 * 	D = (velocity-starting_speed)^2/(2 * acc)
	 *
	 * Similarly, deriving the decel start point is easy as well:
	 *	D = num_steps - (velocity)^2/(2 * dec)
	 *
	 * There be some dragons here though. What happens if we never reach the target velocity b/c the move profile is too short? For decel, the velocity would have to be calculated at
	 * the time of deceleration. Basically, this would be a triangle move instead of a trap move.
	 *
	 * Anyway, that is handled in state_accel. We don't have to worry about that here!
	 *
	 */
	
	/* since these are unsigned integers, we don't have to worry about undefined behavior.
	 * but, we do have to worry about rollover. calc first, then check second.
	 * 
	 * For the acceleration rollover check, look at the distance calculated. Compare it to (velocity-starting_speed)/acc. 
	 * If they are different, we know that something went wrong.
	 *
	 * For the decel rolover check, we should be able to test the same way.
	 *
	 */
	acc_stop_point = pow((this_move->velocity - this_move->starting_speed), 2)/(2 * this_move->acc);
	dec_start_point = this_move->num_steps - (pow(this_move->velocity, 2)/(2 * this_move->dec));

	uint64_t calc_acc_time = (this_move->velocity - this_move->starting_speed)/this_move->acc;
	uint64_t calc_dec_time = (this_move->velocity - this_move)/this_move->dec;
 	
	/* acc test */
	if((acc_stop_point/this_move->velocity) != calc_acc_time)
	{
		fprintf(stderr, "!!! ERROR: acc distance complete time of %" PRIu64 "s is not equal to calculated time of %" PRIu64, acc_stop_point/this_move->velocity, calc_acc_time);
		rc = fail;
	}
	
	/* dec test */
	if((dec_start_point/this_move->velocity) != calc_dec_time)
	{
		fprintf(stderr, "!!! ERROR: dec distance complete time of %" PRIu64 "s is not equal to calculated time of %" PRIu64, dec_stop_point/this_move->velocity, calc_dec_time);
		rc = fail;
	}

	return rc;
}

static int state_accel(void)
{
	enum state_ret_codes rc;

	return rc;
}

static int state_run(void)
{
	enum state_ret_codes rc;

	return rc;
}

static int state_decel(void)
{
	enum state_ret_codes rc;

	return rc;
}

static int state_estop(void)
{
	enum state_ret_codes rc;
	
	printf("!!! E-STOP - Stopping Execution!\n");
	rc = fail;
	return rc;
}

static int state_exit_success(void)
{
	enum state_ret_codes rc;
	
	rc = done;
	return rc;
}

/* exact error message should be printed by the caller */
static int state_exit_fail(void)
{
	enum state_ret_codes rc;
	
	rc = fail;
	return rc;
}

struct move_params init_move_params()
{
	struct move_params m;
	
	m.CW=0;
	m.CCW=0;
	m.acc=-1;
	m.dec=-1;
	m.starting_speed = -1;
	m.velocity=-1;
	m.num_steps=-1;
	m.steps_per_rev=2000;
	
	return m;
}

inline void tsnorm(struct timespec *ts)
{
	while(ts->tv_nsec >= NSEC_PER_SEC)
	{
		ts->tv_nsec -= NSEC_PER_SEC;
		ts->tv_sec++;
	}
		
}
